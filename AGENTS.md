# AGENTS

This file provides guidance to coding agents when working with code in this
repository.

## Repository Structure

**IMPORTANT:** The directory structure has multiple Git repositories:

1. **Parent directory** (`/Users/o0-o/.ansible/collections/ansible_collections/o0_o/`):
   - Has its own Git repository for tracking shared files like AGENTS.md/CLAUDE.md
   - **NEVER add collection content to this repository**
   - Only for cross-collection documentation and configuration

2. **Each collection** is its own independent Git repository:
   - `posix/` - separate Git repository
   - `controller/` - separate Git repository
   - `inventory/` - separate Git repository
   - `connection/` - separate Git repository

**To work with a collection, you must cd into it first:**
```bash
cd posix/     # Enter the posix collection repository
git status    # Now operates on the posix repository

cd ../controller/  # Switch to controller collection repository
git status        # Now operates on the controller repository

cd ..         # Back to parent (only for AGENTS.md, etc.)
git status    # Now operates on the parent repository
```

**CRITICAL:** Never commit collection code to the parent repository. Each collection manages its own code, tests, and documentation.

Current development focuses on the following collections:
- **posix**: Cross-platform utilities with raw fallback support
- **controller**: Ansible controller management
- **inventory**: Inventory and connection management
- **connection**: Connection plugins and utilities

Directories ending in `.wip` are legacy and should be ignored for style reference. However, older Ansible work throughout the repository contains creative automation solutions worth mining for ideas, though it's generally overly complicated due to earlier avoidance of custom modules and plugins.

## Testing Commands

**Individual Collection Testing:**
```bash
# Navigate to collection directory first
cd posix/  # or controller/, inventory/, connection/

# Run all test types
ansible-test sanity --venv
ansible-test units --venv
ansible-test integration --venv
yamllint .  # catches additional formatting issues
```

**Always validate changes:** Run tests before committing to ensure no regressions.
**Never run `pytest` directly, use `ansible-test`**

## GitHub Pages & Docs Reference

- Enable Pages for a collection repo with the GitHub CLI once:
  ```bash
  gh api --method POST \
    -H 'Accept: application/vnd.github+json' \
    /repos/<owner>/<repo>/pages \
    -f build_type=workflow
  ```
  Replace `<owner>/<repo>` as needed.
- For future collections, copy the `utils/` setup when wiring
  `antsibull-docs`, `antsibull-changelog`, and publishing workflows.

### README Philosophy

- Keep each collection README brief and stable. Do not duplicate
  material that is generated and published by `antsibull-docs`.
- Always link to:
  - The collection’s GitHub Pages docs (generated by `antsibull-docs`) — the
    source of truth for plugin lists, parameters, examples, and changelog.
  - The central AGENTS guide for contributor standards:
    https://github.com/o0-o/ansible-collections/blob/main/AGENTS.md
- Recommended README skeleton for all collections:
  1) Title + shields (CI, Galaxy, Docs)
  2) One‑sentence description
  3) Documentation link (GitHub Pages)
  4) Installation snippet (galaxy install)
  5) Contributing (link to central AGENTS)
  6) License
- Do not include plugin tables, long examples, or usage walkthroughs in the
  README — keep those in the generated docs. Let `antsibull-docs` handle the
  details and frequent changes.
- Docs URL pattern examples:
  - posix: https://o0-o.github.io/ansible-collection-posix/
  - utils: https://o0-o.github.io/ansible-collection-utils/

## Antsibull Docs & Changelog Standards

- Every collection must ship the same docs layout as `utils/` and `posix/`:
  `docs/requirements.txt`, `docs/source/` with `antsibull-docs.cfg`, `conf.py`,
  `index.rst`, and a `docs/tools/prebuild.sh` helper that populates
  `docs/source/generated/` via `antsibull-docs` before we run Sphinx.
- GitHub Pages workflows should match the pattern in `utils/.github/workflows/docs.yml`:
  run the prebuild script, call `sphinx-build`, upload the `site/` directory,
  and publish on merges to the default branch (continuous docs). Our docs are
  not versioned; prefer frequent publication over tagged releases.
- Changelogs must be managed through `antsibull-changelog` using
  `changelogs/config.yaml`, `changelogs/changelog.yaml`, and fragments under
  `changelogs/fragments/`. Treat fragments as temporary scratch files—create them
  for each notable change, run
  `antsibull-changelog release --version <next>` when preparing a release, then
  let the tool consume the fragments. **Never hand-edit `changelogs/changelog.yaml`
  or `CHANGELOG.rst`.**
- Add collection-specific README notes reminding contributors that CI runs
  `black`, `flake8`, and `yamllint` before the build, so lint failures will block
  the workflow.


## Code Style Standards

### EOF

**Always end files with a newline character (`\n`)!**

### File Headers

**Python files must use this exact header:**
```python
# vim: ts=4:sw=4:sts=4:et:ft=python
# -*- mode: python; tab-width: 4; indent-tabs-mode: nil; -*-
#
# GNU General Public License v3.0+
# SPDX-License-Identifier: GPL-3.0-or-later
# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
#
# Copyright (c) 2025 oØ.o (@o0-o)
#
# This file is part of the o0_o.<collection_name> Ansible Collection.
```

**YAML files must use this exact header:**
```yaml
# vim: ts=2:sw=2:sts=2:et:ft=yaml.ansible
# -*- mode: yaml; yaml-indent-offset: 2; indent-tabs-mode: nil; -*-
---
# GNU General Public License v3.0+
# SPDX-License-Identifier: GPL-3.0-or-later
# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
#
# Copyright (c) 2025 oØ.o (@o0-o)
#
# This file is part of the o0_o.<collection_name> Ansible Collection.
```

### Code Style and Linting

**Always rely on automatic formatting first, then check for remaining issues:**

#### Python (PEP 8 Compliance)

1. **ALWAYS run black first for automatic formatting:**
   ```bash
   # From collection directory
   git ls-files | grep "\.py$" | xargs black
   ```

   **Benefits of black:**
   - Consistent formatting across all code
   - No debates about style choices
   - Handles most PEP 8 requirements automatically
   - Saves time on manual formatting
   - Use it liberally - run it often!

2. **Then check for remaining issues with flake8:**
   ```bash
   git ls-files | grep "\.py$" | xargs flake8
   ```

3. **Only manually fix what black cannot handle:**
   - Long docstrings (W505) - break at 72 characters
   - Complex line length issues black couldn't resolve
   - Import order issues in special cases

#### YAML Formatting

4. **Check YAML files with yamllint:**
   ```bash
   yamllint .
   ```

   **Common yamllint fixes:**
   - Line length (79 characters) - use multiline Jinja2 format
   - Indentation issues (2 spaces for YAML)
   - Missing document start (`---`)
   - Trailing spaces

**Complete workflow:**
```bash
# From collection directory
black .                                      # Auto-format Python
git ls-files | grep "\.py$" | xargs flake8  # Check Python issues
yamllint .                                   # Check YAML issues
# Fix only the remaining issues manually
```

**Configuration:**
- **Python line length**: 79 characters (enforced by black and flake8)
- **YAML line length**: 79 characters (enforced by yamllint)
- **Doc/comment length**: 72 characters (enforced by flake8)
- **E402 (imports)**: Ignored for module files only (see pyproject.toml)
- **Indentation**: 4 spaces for Python, 2 spaces for YAML
- **Use `from __future__ import annotations` for type hint support**

### String Quoting Standards

**Python:** Black handles quoting automatically (prefers double quotes).

**YAML:** Prefer single quotes for plain strings:
```yaml
greeting: 'Hello world'

# Double quotes for special cases
content: "Multi-line\nwith escapes"  # Escape sequences
template_var: "{{ jinja_expression }}"  # Jinja2
apostrophe: "Can't process this"  # Contains single quote
```

**Long Jinja2 expressions - use >- multiline format:**
```yaml
# Correct
- name: Parse fstab content
  ansible.builtin.set_fact:
    fstab_parsed: >-
      {{ fstab_content_reg['content']
         | b64decode
         | o0_o.posix.fstab }}

# For conditionals
  when: >-
    '.' in parsed_default['hostname'].get('long',
                                           parsed_default['hostname']['short'])

# Incorrect - line too long
    fstab_parsed: "{{ fstab_content_reg['content'] | b64decode | o0_o.posix.fstab }}"
```

**Prefer {} over dict():**
```python
# Correct
argument_spec = {
    "gather_subset": {
        "type": "list",
        "default": ["all"]
    }
}

# Incorrect
argument_spec = dict(gather_subset=dict(...))  # Wrong

# Exception: dict(bar) for conversion is valid
```

### Bracket vs Dot Notation

**MANDATORY: ALWAYS use bracket notation for dictionary access - NO EXCEPTIONS**

Dot notation is NEVER acceptable for dictionary access (except within string arguments to filters like selectattr).

**Python:**
```python
# Correct
kernel_name = un_s["stdout_lines"][0]
facts = result.get("ansible_facts", {})

# Incorrect
kernel_name = un_s.stdout_lines[0]  # Wrong!
```

**Ansible/YAML:**
```yaml
# Correct
- name: Check command result
  ansible.builtin.assert:
    that:
      - command_result_reg['rc'] == 0
      - "'success' in command_result_reg['stdout']"

# Incorrect
- ansible.builtin.assert:
    that:
      - command_result_reg.rc == 0  # Wrong!
```

**Why:**
- Breaks with special characters or spaces in keys
- Causes silent failures with undefined values
- Only brackets work consistently in Python and Jinja2

**Common violations:**
```yaml
when: result.changed              # WRONG
when: result['changed']            # CORRECT

var: my_dict.some_key              # WRONG
var: my_dict['some_key']           # CORRECT
```

**Exception - string arguments to filters:**
```yaml
{{ items | selectattr('result.status', 'equalto', 'active') }}  # OK
when: item['status'] == 'active'  # Still use brackets for variable access
```

**Acceptable dot notation - object attributes only:**
```python
self._display.vvv(message)
self._task.check_mode
```

### Exception Variable Naming

**Use `e` as the exception variable name for simple exception handling:**

```python
# Standard pattern
try:
    result = some_operation()
except AnsibleActionFail as e:
    self._display.warning(f"Operation failed: {e}")
    raise
except Exception as e:
    return {"failed": True, "msg": f"Unexpected error: {e}"}

# Avoid verbose names for simple cases
except Exception as exc:   # Unnecessarily verbose
except Exception as error: # Unnecessarily verbose
```

**For nested or complex exception handling, use descriptive names as needed:**
```python
# Nested exceptions - use pragmatic naming
try:
    connection = establish_connection()
except ConnectionError as connection_error:
    try:
        fallback = use_fallback_method()
    except FallbackError as fallback_error:
        self._display.warning(
            f"Both methods failed: primary={connection_error}, "
            f"fallback={fallback_error}"
        )
```

### Type Hints and Documentation

**ALWAYS include docstrings - no exceptions:**

**Complex methods - full reST-style:**
```python
def method_name(self, param1: str, param2: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """Short description of method purpose.

    Longer description explaining behavior, side effects, and context.

    :param str param1: Description of the parameter
    :param Optional[Dict[str, Any]] param2: Description with default info
    :returns Dict[str, Any]: Description of return value structure
    :raises AnsibleActionFail: When and why this exception occurs
    """
```

**Simple functions and tests - brief docstrings:**
```python
def test_mount_parser_with_spaces():
    """Test that mount parser handles paths with spaces correctly."""

def get_mount_point(path: str) -> str:
    """Extract mount point from path."""
    return path.split()[0]

@pytest.fixture
def filter_module() -> FilterModule:
    """Create a FilterModule instance for testing."""
    return FilterModule()
```

**Docstring continuation (>72 chars) - use 4-space indentation:**
```python
    :param Optional[Dict[str, Any]] task_vars: Available Ansible
        variables passed from the task execution context
    :returns Dict[str, Any]: The result dictionary containing keys
        like 'changed', 'msg', and any custom return values
```

**Standards:**
- Always include docstrings (even one-liners)
- Full type annotations: `Optional[Dict[str, Any]]`, not `dict | None`
- Use `Tuple[str, Optional[str]]` not `tuple[str, Optional[str]]`
- Variable naming: `result` not `results`, `task_vars` not `variables`
- Continuation lines: 4-space indentation from line start

## Action Plugins

### Class variables/attributes

**All action plugins must define the following at the class level:**

```python
TRANSFERS_FILES  # does this plugin transfer a file from controller to host?
_requires_connection  # only false if all operations are on the controller
_supports_check_mode  # usually true if any check_mode operations are present
_supports_diff  # true if using writing to text-based files
_supports_async  # usually false unless explicitly set to True
```

None of these should be set within class methods.

If \_supports\_async is False, no async-related operations should be in class methods.


## Testing Standards

### Test Utilities & Conftest

- Always check for existing helpers before writing new ones:
  - `tests/utils/` for reusable utilities (e.g., paths, commands, mounts).
  - Any `conftest.py` near your tests for shared fixtures.
- Prefer reusing helpers over inlining mocks; if you repeat patterns,
  contribute a small, focused helper to `tests/utils/` and export it in
  `tests/utils/__init__.py` for discoverability.
- For error-path tests, use a simple raiser helper instead of custom
  lambdas. Example pattern supported in collections:
  ```python
  from tests.utils import boom

  # Force a function to raise during monkeypatch
  monkeypatch.setattr("pkg.module.func", boom(ValueError("boom")))
  ```
- Use `monkeypatch` for local, readable scoping; keep mocks minimal and
  targeted. Maintain parametrize for variations and keep filter wrapper
  tests light when core helpers are well-covered elsewhere.

### Imports

- Do not import inside functions or methods. Keep imports at module
  top for clarity, tooling, and performance.
- Acceptable exceptions at module scope only:
  - Optional dependencies behind try/except ImportError guards
  - Version-gated imports (e.g., different imports across Ansible
    versions)
  - TYPE_CHECKING imports for typing-only references
- Never import a parent package just to shorten a long import path;
  prefer exporting via `module_utils/__init__.py` and using the shorter
  public import instead (with `# noqa: E501` only where absolutely
  necessary).

### Display & Warnings

- Always identify the host in warnings. Use a common helper to format
  messages consistently so they can be correlated to a specific
  inventory host in multi-host runs.
- In action plugins derived from `PosixActionBase`, prefer:
  ```python
  host = self._get_inventory_hostname(task_vars)
  self._display.warning(f"[{host}] message text here")
  ```
- Default to `localhost` when `inventory_hostname` is not available.

### Unit Test Structure

**Use pytest with consistent fixture patterns:**
```python
@pytest.fixture
def plugin(base):
    '''
    Create an ActionModule instance with patched dependencies from the
    shared `base` fixture for testing purposes.
    '''

def test_get_kernel_and_hardware_success(monkeypatch, plugin):
    '''
    Test successful gathering of POSIX kernel and hardware facts using `uname`.
    '''

@pytest.mark.parametrize('subset,expect_os,expect_hw', [
    (['all'], True, True),
    (['kernel'], True, False),
    (['arch'], False, True),
    (['!kernel'], False, True),
])
def test_run_subset_selection(monkeypatch, plugin, subset, expect_os, expect_hw):
    '''
    Test gather_subset filtering and resulting fact inclusion logic.
    '''
```

### Unit Test Best Practices

**Prefer parametrize for testing variations:**
```python
# GOOD - Concise and maintainable
@pytest.mark.parametrize('input_str,expected', [
    ("/dev/sda1 on / type ext4 (rw)", {"mount": "/", "source": "/dev/sda1"}),
    ("tmpfs on /run type tmpfs (rw,nosuid)", {"mount": "/run", "source": "tmpfs"}),
])
def test_parse_mount_variations(input_str, expected):
    """Test mount parsing with various input formats."""
    assert parse_mount_line(input_str) == expected

# BAD - Repetitive separate functions for each case
```

**Keep mocking simple:**
```python
# GOOD - Mock only what's necessary
def test_parse_mount_with_spaces(filter_module):
    """Test mount parsing handles paths with spaces."""
    mount_output = "/dev/sda1 on /mnt/my files type ext4 (rw,relatime)"
    result = filter_module.filters()["mount"](mount_output)
    assert result[0]["mount"] == "/mnt/my files"

# GOOD - Mock specific failure conditions
def test_jc_parse_error(filter_module):
    """Test filter handles jc parse errors gracefully."""
    with patch("...jc.parse", side_effect=Exception("Parse error")):
        with pytest.raises(AnsibleFilterError, match="df failed"):
            filter_module.filters()["df"]("invalid output")
```

**Avoid over-testing wrappers:**
```python
# If core function is tested, wrapper only needs basic verification
def test_mount_filter_wrapper(filter_module):
    """Test filter correctly wraps parse_mount_line."""
    mount_filter = filter_module.filters()["mount"]
    assert callable(mount_filter)
    assert isinstance(mount_filter("test output"), list)
```

**Testing guidelines:**
- Use parametrize for variations
- Mock only external dependencies and failures
- Use real functions when possible
- Don't duplicate tests for wrappers
- Keep test data realistic and minimal

### Test Data Organization

**Store long test data (>5-10 lines) in separate files:**
```python
# GOOD - Load from file
def test_parse_complex_mount():
    """Test parsing complex mount output."""
    test_data_dir = Path(__file__).parent / "files"
    mount_output = (test_data_dir / "mount_complex.txt").read_text()
    result = parse_mount(mount_output)

# BAD - Inline multi-line data clutters test
```

**Test file structure:**
```
tests/
├── unit/
│   ├── utils/           # Shared helpers (mounts.py, real_cmd.py, etc.)
│   └── plugins/filter/
│       ├── files/       # Test data (mount_basic.txt, fstab_sample.txt)
│       └── test_mount.py
└── integration/targets/<module_name>/
    ├── files/           # Test data for integration tests
    └── tasks/
```

**Loading test data:**
```python
@pytest.fixture
def test_data_dir():
    """Path to test data files directory."""
    return Path(__file__).parent / "files"

def test_with_file_data(test_data_dir):
    """Test using data from file."""
    input_data = (test_data_dir / "input.txt").read_text()
    expected = json.loads((test_data_dir / "expected.json").read_text())
    assert some_function(input_data) == expected
```

### Integration Test Structure

**Use YAML with proper task organization:**
```yaml
- name: Run success tests
  ansible.builtin.include_tasks: facts.yml
  loop:
    - true
    - false
  vars:
    ansible_check_mode: '{{ item }}'
```

### Variable Naming Conventions

**ALL Ansible code must follow these variable naming standards:**

**Registered Variables - use descriptive names with `_reg` suffix:**
```yaml
# Correct
- name: Run command with argv
  o0_o.posix.command:
    argv: [echo, foo]
  register: command_argv_reg

# Incorrect - too generic
  register: result  # Wrong!
```

**Variable Declarations - use `_var` suffix or descriptive names:**
```yaml
# Correct
vars:
  greeting_var: 'Hello world'
  files_dir_var: "{{ playbook_dir }}/files"
  dest_path: /tmp/output  # Acceptable for established patterns
```

**Facts Access - use direct access instead of indirection:**
```yaml
# Correct
- assert:
    that:
      - o0_os['kernel']['name'] == 'Linux'

# Incorrect - unnecessary indirection through registered variable
- o0_o.posix.facts:
  register: facts_result_reg
- assert:
    that:
      - facts_result_reg['ansible_facts']['o0_os']['kernel']['name'] == 'Linux'
```

**Variable References - always use bracket notation:**
```yaml
# Correct
that:
  - command_result_reg['rc'] == 0

# Incorrect
that:
  - command_result_reg.rc == 0  # Wrong!
```

### Failure Testing Standards

**ALWAYS use block/rescue pattern for testing expected failures:**

```yaml
# Preferred approach
- name: 'Fail: Test expected error condition'
  block:

    - name: Run operation that should fail
      module_name:
        invalid_param: value

  rescue:

    - name: Assert failure occurred as expected
      ansible.builtin.assert:
        that:
          - "'expected error' in ansible_failed_result['msg']"
```

**DO NOT use ignore_errors for failure testing:**
```yaml
# Incorrect approach - avoid this pattern
- name: Test that should fail
  module_name:
    invalid_param: value
  ignore_errors: true
  register: result

- name: Assert failure
  assert:
    that:
      - result is failed
```

**Exception: ignore_errors is acceptable for version compatibility testing where operations might legitimately succeed or fail based on Ansible version.**

### Integration Test Best Practices

**Directory Structure:**
```
tests/integration/targets/<module_name>/
├── tasks/
│   ├── main.yml         # Entry point with test orchestration
│   ├── test_success.yml # Success case tests
│   └── test_failures.yml# Failure case tests
├── files/               # Static test files (siblings of tasks/, not inside)
│   └── input.txt
└── templates/           # Jinja2 templates (siblings of tasks/, not inside)
    └── test_template.j2
```

**Test Organization:**
```yaml
# main.yml - Test orchestration with cleanup
- name: Create temporary directory
  ansible.builtin.tempfile:
    state: directory
    suffix: module_test
  register: test_tmpdir_reg

- name: Try
  block:
    - name: Run test set with permutations
      ansible.builtin.include_tasks: "{{ item[0] }}"
      loop: "{{ test_sets | product(loop_list) }}"
      vars:
        test_sets: [test_success.yml, test_failures.yml]
        loop_list: "{{ [true, false] | product([true, false]) }}"
        _force_raw: "{{ item[1][0] }}"
        ansible_check_mode: "{{ item[1][1] }}"
  always:
    - name: Clean up
      ansible.builtin.file:
        path: "{{ test_tmpdir_reg.path }}"
        state: absent
```

**Key Practices:**
- **DRY**: Define repeated variables centrally in include_tasks vars, not in each task file
- **Directory variables**: Set `files_dir_var` and `templates_dir_var` in main.yml
- **Loop control**: Use `loop_control.loop_var` to avoid variable collisions with `ansible_check_mode`

```yaml
# Example: Avoid collisions
- ansible.builtin.include_tasks: single_test.yml
  loop: "{{ test_parameters }}"
  loop_control:
    loop_var: test_param  # Prevents conflicts
```

## Plugin Development Patterns

### Class Structure
```python
class ActionModule(PosixActionBase):
    '''Brief description of the plugin\'s purpose'''

    TRANSFERS_FILES = False
    _requires_connection = False
    _supports_check_mode = True
    _supports_async = False
```

### Argument Validation
```python
argument_spec = {
    "gather_subset": {
        "type": "list",
        "elements": "str",
        "default": ["all"],
        "choices": [
            "all", "kernel", "arch",
            "!all", "!kernel", "!arch"
        ]
    }
}

validation_result, new_module_args = self.validate_argument_spec(
    argument_spec=argument_spec
)
```

### Error Handling
```python
try:
    result = self._execute_action(task_vars=task_vars)
except AnsibleConnectionFailure:
    raise  # Re-raise connection failures
except Exception as e:
    self._display.vvv(
        f"Operation failed: {type(e).__name__}: {e}"
    )
    result.update({
        "failed": True,
        "msg": f"Error during execution: {e}"
    })
    return result
```

### Dictionary Operations
```python
# Always use bracket notation and {}
result.update({
    "skipped": True,
    "skip_reason": "This does not appear to be a POSIX system.",
    "ansible_facts": {}
})

# Prefer .get() with defaults
facts = result.get("ansible_facts", {})
config = task_vars.get("hostvars", {}).get(inventory_hostname, {})
```

### Filter Plugins

**Filter plugins must follow naming conventions and include proper documentation:**
```python
def mount(data: Union[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Parse mount command output into structured data.

    :param data: Mount command output as string or command result dict
    :returns: List of mount entries with source, mount, type, and options
    """
```

**Standards:**
- Accept multiple input formats (string, command dict, slurp result)
- Return consistent structured data
- Include comprehensive unit tests
- Use shared utilities from module_utils when appropriate

### Module Utils Organization and Imports

**Import rules to avoid circular dependencies:**

**External imports (from other packages) - use __init__.py exports:**
```python
# CORRECT - importing from module_utils in your plugin
from ansible_collections.o0_o.posix.plugins.module_utils import (
    PosixActionBase,
    parse_mount_line
)

# WRONG - bypassing __init__.py for external imports
from ansible_collections.o0_o.posix.plugins.module_utils.posix_action_base import (
    PosixActionBase  # Wrong! Use __init__.py export
)
```

**Internal imports (within module_utils) - use direct imports:**
```python
# CORRECT - inside module_utils/mount_utils.py
from ansible_collections.o0_o.posix.plugins.module_utils.fstab_utils import (
    normalize_entry
)

# WRONG - using __init__.py within the same directory causes circular imports
from ansible_collections.o0_o.posix.plugins.module_utils import (
    normalize_entry  # Wrong! Circular import risk
)
```

**Standards:**
- Export commonly used classes/functions in `module_utils/__init__.py`
- External consumers always import via `__init__.py`
- Within `module_utils/`, use direct file imports to avoid circular dependencies
- Use consistent naming: `mount_utils.py`, `fstab_utils.py`
- Use `# noqa: E501` for unavoidably long imports

## Module Documentation

**All modules must include comprehensive DOCUMENTATION:**
```python
DOCUMENTATION = r'''
---
module: facts
short_description: Gather POSIX facts from the managed host
version_added: "1.1.0"
description:
  - Collects minimal OS and hardware facts from POSIX-compatible remote hosts.
  - Uses raw shell commands like C(uname) to gather kernel name, version,
    and CPU architecture.
  - Does not require Python on the managed host.
options:
  gather_subset:
    description:
      - Specify which fact subsets to gather.
    type: list
    elements: str
    default: ['all']
    choices: ['all', 'kernel', 'arch', '!all', '!kernel', '!arch']
seealso:
  - module: ansible.builtin.setup
    description: Gather facts about remote hosts
'''
```

### Common ansible-test Validation Issues

**Avoid these common pitfalls that cause ansible-test failures:**

1. **Module Documentation seealso section:**
   ```yaml
   # CORRECT - use 'module:' for module references
   seealso:
     - module: ansible.builtin.stat
       description: Retrieve file status

   # WRONG - 'name:' is not valid for modules
   seealso:
     - name: ansible.builtin.stat  # This will fail validation!
       description: Retrieve file status
   ```

2. **RETURN Documentation structure:**
   ```yaml
   # CORRECT - merge behavioral notes into description
   RETURN = r'''
   file:
     description: >-
       File metadata dictionary.
       When I(recursive=true) this includes nested data.
     type: dict
   '''

   # WRONG - 'notes' field not allowed at nested levels
   RETURN = r'''
   file:
     description: File metadata dictionary
     type: dict
     notes:  # This will fail validation!
       - When recursive=true behavior changes
   '''
   ```

3. **Variable naming in action plugins:**
   ```python
   # CORRECT - use descriptive names for all variables
   validation_result, new_args = self.validate_argument_spec(
       argument_spec=argument_spec
   )

   # WRONG - underscore alone is a disallowed name
   _, new_args = self.validate_argument_spec(  # Will fail pylint!
       argument_spec=argument_spec
   )
   ```

4. **Test docstring format:**
   ```python
   # CORRECT - action-oriented test descriptions
   def test_locale_from_command(monkeypatch, plugin) -> None:
       """Test successful parsing of locale command output."""

   # WRONG - passive voice without "Test"
   def test_locale_from_command(monkeypatch, plugin) -> None:
       """Parse locale output into categories."""  # Less clear
   ```

## Release Management

### Changelogs
We are migrating to antsibull-changelog for changelog management. Use standard Ansible changelog format:

```yaml
# changelog.yml or changelogs/changelog.yaml (depending on collection)
releases:
  1.3.0:
    # Do not include release_date unless it's part of antsibull-changelog behavior
    changes:
      major_changes:
        - Added raw fallback support for systems without Python
      minor_changes:
        - Enhanced error handling in connection plugins
      bugfixes:
        - Fixed regex compilation issue in lineinfile_dedupe
      breaking_changes:
        - Removed deprecated legacy_mode parameter
```

**Do not mention specific linters**: black, flake8, ansible-lint, etc.

**Do not manually add release_date** - let antsibull-changelog handle this automatically.

The changelog location varies by collection - check for `changelog.yml` or `changelogs/changelog.yaml`

### Git Workflow

**Branch Strategy:**
- `main`: Stable release branch
- `formatting-consistency`: Active development branch for style improvements
- Feature branches: For specific enhancements or fixes

**Commit Standards:**

Use HEREDOC format for commit messages:
```bash
git commit -m "$(cat <<'EOF'
Short summary line

Detailed description of changes and reasoning.
Multiple lines explaining the what and why.

Tests pass with ansible-test sanity, units, and integration.

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

**Notes:**
- Claude signature (🤖 and Co-Authored-By) only for Claude itself
- Other AI agents: use own attribution or none at all
- Do not mention specific linters in commit messages
- Do not use `origin` as remote name, use `github` or similar

### Git Tagging
Use semantic versioning with v prefix:
```bash
git tag -a v1.3.1 -m 'Release v1.3.1 - Description of changes'
git tag -a v1.0.1 -m 'Release v1.0.1 - Description of changes'
```

### README Structure
All collection READMEs must follow this rigid structure:

```markdown
# o0_o.<collection_name>

Brief description and purpose.

## Overview

Detailed description of the collection's functionality and key features.

## Installation

```bash
ansible-galaxy collection install o0_o.<collection_name>
```

## Dependencies

List required collections and external dependencies.

## Usage

### Basic Examples
Provide simple, practical examples.

### Advanced Usage
More complex examples and patterns.

## Plugins

### Action Plugins
List and describe each plugin.

### Modules
List and describe each module.

### Roles
List and describe each role (if applicable).

## Development & Testing

```bash
ansible-test sanity --venv
ansible-test units --venv
ansible-test integration --venv
```

## License

Licensed under the [GNU General Public License v3.0](https://www.gnu.org/licenses/gpl-3.0.txt) or later (GPLv3+)
```

## Architecture Notes

### Base Classes
- Extend `PosixActionBase` for action plugins requiring raw fallback
- Use `self._display.vvv()` for verbose logging
- Always implement proper check mode support

### Connection Handling
- Support multiple connection types (ssh, network_cli, local)
- Implement graceful fallbacks for systems without Python
- Test connection capabilities before complex operations

### Collections Interdependencies
- `posix` provides base utilities used by other collections
- `inventory` and `connection` work together for host management
- `controller` manages Ansible infrastructure itself

When making changes, ensure consistency with these established patterns and always include comprehensive tests and documentation.

**Important:** For ansible-test commands, always use the --venv at the very end. Anything after --venv will be silently ignored.
